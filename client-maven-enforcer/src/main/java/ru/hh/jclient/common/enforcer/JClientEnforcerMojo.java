package ru.hh.jclient.common.enforcer;

import com.thoughtworks.qdox.JavaProjectBuilder;
import com.thoughtworks.qdox.Searcher;
import com.thoughtworks.qdox.model.JavaAnnotation;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.expression.AnnotationValue;
import com.thoughtworks.qdox.model.expression.AnnotationValueList;
import com.thoughtworks.qdox.model.impl.DefaultJavaAnnotation;
import com.thoughtworks.qdox.model.impl.DefaultJavaMethod;
import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import static java.util.stream.Collectors.toSet;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import ru.hh.jclient.common.JClient;
import ru.hh.jclient.common.JResource;

@Mojo(name = "enforceJClient", defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES, threadSafe = true)
public class JClientEnforcerMojo extends AbstractMojo {

  @Parameter(defaultValue = "${reactorProjects}", readonly = true)
  List<MavenProject> projects;

  /** The maven project (effective pom). */
  @Parameter(defaultValue = "${project}", readonly = true)
  private MavenProject project;

  /** The output directory into which to find the resources. */
  @Parameter(property = "project.build.outputDirectory")
  private File outputDirectory;

  /** The output directory into which to find the source code. */
  @Parameter(property = "project.build.sourceDirectory")
  private File sourceDirectory;

  @Parameter(required = true)
  private File clientSourceDirectory;

  @Override
  public void execute() throws MojoExecutionException, MojoFailureException {
    if (clientSourceDirectory == null || !clientSourceDirectory.exists()) {
      throw new MojoExecutionException("clientSourceDirectory not specified or points to non-existing directory");
    }

    JavaProjectBuilder builder = prepareBuilder(sourceDirectory);
    Map<JavaAnnotation, Collection<String>> resourceAnnotations = findAndResolve(builder, JClient.class);
    Set<String> resourceAnnotationValues = resourceAnnotations.values().stream().flatMap(Collection::stream).collect(toSet());

    builder = prepareBuilder(clientSourceDirectory);
    Map<JavaAnnotation, Collection<String>> clientAnnotations = findAndResolve(builder, JResource.class);
    Set<String> clientAnnotationValues = clientAnnotations.values().stream().flatMap(Collection::stream).collect(toSet());

    boolean resourcesInvalid = resourceAnnotations
        .entrySet()
        .stream()
        .map(e -> checkValidOrReport(e.getKey(), e.getValue(), clientAnnotationValues, "is not referenced by any clients"))
        .collect(toSet())
        .contains(false);
    boolean clientsInvalid = clientAnnotations
        .entrySet()
        .stream()
        .map(e -> checkValidOrReport(e.getKey(), e.getValue(), resourceAnnotationValues, "is not referenced by any resources"))
        .collect(toSet())
        .contains(false);

    if (resourcesInvalid || clientsInvalid) {
      throw new MojoExecutionException("Annotations are missing");
    }
  }

  private boolean checkValidOrReport(JavaAnnotation annotation, Collection<String> fields, Set<String> otherSide, String message) {
    // need to report ALL fields so can't use anyMatch() etc
    return !fields.stream().map(f -> checkFieldValidOrReport(annotation, f, otherSide, message)).collect(toSet()).contains(false);
  }

  private Boolean checkFieldValidOrReport(JavaAnnotation annotation, String field, Set<String> otherSide, String message) {
    if (otherSide.contains(field)) {
      return true;
    }

    DefaultJavaAnnotation detailedAnnotation = (DefaultJavaAnnotation) annotation;
    DefaultJavaMethod detailedMethod = (DefaultJavaMethod) detailedAnnotation.getContext();
    StringBuilder errorString = new StringBuilder();
    if (detailedMethod.getParentClass() != null) {
      errorString.append(detailedMethod.getParentClass().getFullyQualifiedName()).append(".");
    }
    errorString
        .append(detailedMethod.getName())
        .append("(...):")
        .append(detailedMethod.getLineNumber())
        .append(" pointing to ")
        .append(field)
        .append(" ")
        .append(message);

    getLog().error(errorString);
    return false;
  }

  private JavaProjectBuilder prepareBuilder(File sourcesDirectory) {
    getLog().info("Scanning " + sourcesDirectory);
    JavaProjectBuilder builder = new JavaProjectBuilder();
    builder.setErrorHandler(e -> getLog().warn(e.getMessage()));
    builder.addSourceTree(sourcesDirectory, f -> getLog().warn("Failed to parse file " + f));
    getLog().info("Found " + builder.getClasses().size() + " classess");
    getLog().info("Found " + builder.getSources().size() + " sources");
    return builder;
  }

  private Map<JavaAnnotation, Collection<String>> findAndResolve(JavaProjectBuilder builder, Class<?> annotationClass) {
    return builder
        .search(new AnnotationSearcher(annotationClass))
        .stream()
        .flatMap(c -> c.getMethods().stream())
        .flatMap(m -> m.getAnnotations().stream())
        .filter(a -> a.getType().getFullyQualifiedName().equals(annotationClass.getName()))
        .collect(Collectors.toMap(Function.identity(), this::resolveField));
  }

  private Collection<String> resolveField(JavaAnnotation annotation) {
    Collection<String> names;
    AnnotationValue value = annotation.getProperty("value");
    if (value instanceof AnnotationValueList) {
      names = ((AnnotationValueList) value).getValueList().stream().map(a -> a.getParameterValue().toString()).collect(Collectors.toList());
    }
    else {
      names = Collections.singleton(value.getParameterValue().toString());
    }

    // search fieldName in static imports
    return names.stream().map(n -> resolveSingleField(annotation, n)).collect(Collectors.toList());
  }

  private String resolveSingleField(JavaAnnotation annotation, String fieldName) {
    DefaultJavaAnnotation detailedAnnotation = (DefaultJavaAnnotation) annotation;
    List<String> imports = ((DefaultJavaMethod) detailedAnnotation.getContext()).getDeclaringClass().getSource().getImports();

    if (!fieldName.contains(".")) {
      // static import, i.e.
      //
      // import static com.example.Paths.GET_ALL
      // ...
      // @JResource(GET_ALL)
      return imports
          .stream()
          .filter(i -> i.startsWith("static "))
          .filter(i -> i.endsWith("." + fieldName))
          .map(i -> i.substring("static ".length()))
          .findFirst()
          .orElse(fieldName);
    }

    // regular import, i.e.
    //
    // import com.example.Paths;
    // ...
    // @JResource(Paths.GET_ALL)
    // or
    // @JResource(com.example.Paths.GET_ALL)
    String constantName = fieldName.substring(fieldName.lastIndexOf('.') + 1);
    String className = fieldName.substring(0, fieldName.lastIndexOf('.'));

    Optional<String> importString = imports.stream().filter(i -> i.endsWith(className)).findFirst().map(i -> i + "." + constantName);

    // return original on everything else
    return importString.orElse(fieldName);
  }

  private static class AnnotationSearcher implements Searcher {

    private final String annotationClassName;

    public AnnotationSearcher(Class<?> annotationClass) {
      this.annotationClassName = annotationClass.getName();
    }
    @Override
    public boolean eval(JavaClass cls) {
      return cls.getMethods().stream().flatMap(m -> m.getAnnotations().stream()).anyMatch(
          a -> a.getType().getFullyQualifiedName().equals(annotationClassName));
    }
  }
}
